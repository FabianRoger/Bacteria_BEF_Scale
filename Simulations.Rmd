---
title: "Bacterial EF across Scale - Simulations"
output: html_notebook
---

```{r, message=FALSE}
library(dplyr)
library(tidyr)
library(purrr)
library(ggplot2)
library(broom)
library(RColorBrewer)
library(viridis)
library(here)
library(pbapply)
library(nlstools)
```

This script exports: 

+ the subplots for Figure 2
+ the subplots for Figure S2
+ Figure S1

See script `Multipanel_Fig_2.Rmd` for the assemblage and export of figure 2. 

To generate the subplots for Figure S2, the `Scenario` Variable (line 135) has to be set to `1` and `2` respectively, and the code from line 135 to line 420 has to be run with these valules respectively. Figure S2 is then assembled and exported from the same script as Figure 2. 

make folder to export figures
```{r}

if(! dir.exists(here("figures"))){
  dir.create(here("figures"))
}

```


#set up simulations

+ We want to simulate 5 strains of Bacteria, growing in 5 different environments. 
+ Each Strain differs in it's ability to grow on each antibiotic.
+ We grow the bacteria in every possible combination (monocultures and all possible species mixtures)
+ We grow them on every possible combination of environments
+ We measure EF at different scales going from 1 to 5 environments  

define number of species and environments
```{r}

specnum <- 5
envnum <- 5
 
```

## strains

We create 5 species (for `specnum = 5`) named strain_1 to strain_5 and get every possible combination of the five species for all 1,2,3,4 and 5 species combination (corresponding richness levles 1:5 in a biodiversity experiment)

```{r}
spec <- paste("strain_", c(1:specnum), sep = "")
spec_comb <- sapply(c(1:specnum), function(x) combn(spec, x)) 
names(spec_comb) <- paste("richness", c(1:specnum))
```

## environments

We create 5 environments (for `envnum = 5`) named Environment_1 to Environment_5 and get every possible combination of the five environments for all 1,2,3,4 and 5 environment combinations (corresponding to the different scales)

```{r}
env <- paste("Environment_", c(1:envnum), sep = "")
env_comb <- sapply(c(1:envnum), function(x) combn(env, x)) 
names(env_comb) <- paste("Heterogeneity", c(1:envnum))
```

number of combinations

```{r}
tibble(spec_combs = 
         sum(choose(specnum,1:specnum)),
       env_combs = 
         sum(choose(envnum,1:envnum)))
```

## fitness values

We assign each strain a fitness value for each environment. The values are drawn from a uniform distrubtion (0,1) for each strain and each environment. 

```{r}

set.seed(1346)

Traits <- matrix(
  nrow = length(env),
  ncol = length(spec),
  dimnames = list(env, spec))


Traits[1:nrow(Traits), 1:ncol(Traits)] <-
  runif( n = prod( dim( Traits)), 0, 1)

Traits
```

#run simulations

##plot values

here we calculate the outcome (biomass / 'functioning') of every species combination in each environment. We calculate the mixture performance in three differen ways:

1) **Dominance**: The mixture value equals the perfomance of the best performing species 
2) **Mean**: The mixture value equals the mean of the performances of all species 

3) **Weighted mean**: The mixture value equals the mean performance of all species, weighted by their relative performance in the environemnt

**we present the wighted mean in the main article**

*what the code does*

for each environment `sapply(env, ...` it cycles through all richness levels `lapply(spec_comb, ...)` and for each richness level it cycles through all species combinations `apply(..., 2, )`.
Then it calculates the mixture performance of that species combination of that richness level in that environment given the species performance stored in `Traits` and given the rules in the chosen `Scenario`

Choosing Scenario = 3 produces the results in the main text and the subplots for Figure 2
Choosing Scenarion = 1 & 2 produces the subplots for supplemantary Figure S1

```{r}

# choose scenario

# 1 = Dominance
# 2 = Mean
# 3 = Weighted mean


Scenario <- 3

plot_values <- sapply(env, #for each environment
                      function(x) {
                        lapply(spec_comb, #for each richness level
                               function(y) {
                                 apply(y, 2, function(z){ #for each species combination
                                   if(Scenario == 1){
                                     max(Traits[x,z])
                                     } else if(Scenario == 2){
                                     mean(Traits[x,z])
                                       } else {
                                         mean(sum(Traits[x,z]^2) / abs(sum(Traits[x,z])))
                                       } 
                                   }
                                   )
                                 }
                               )
                        }
                      )


plot_values_df <- 
  tibble(
    richness = rep( rep(1:specnum, unlist(lapply(spec_comb, ncol))), envnum),
    spec_comb = rep(lapply(spec_comb, 
                           function(x) apply(x, 2, function(y) 
                             paste(y, collapse = " "))) %>% unlist(),
                    envnum),
    environment = rep(env, each = sum(choose(specnum,1:specnum))),
    functioning = unlist(plot_values)
    )

#small random error so that the function fitting functions don't fail

# plot_values_df <- 
#   plot_values_df %>% 
#   mutate(functioning = functioning + rnorm(n(), 0, 0.01)) %>% 
#   mutate(functioning = functioning + abs(min(functioning)) + 0.01)

```

### plot plot-values

Here we plot the single species and mixture functioning of each species combination in each environment. The Mixture performance is calculated as the weighted mean of the monoculture performances. 

We show a power-fit (with 2*se CI) and a linear fit, both showing the positive richness ~ functioning relationship (that follows inherently from the way we calculate the mixture values)

```{r}

plot_values_df %>% 
  na.omit() %>% 
  group_by(environment) %>%
  nest() %>% 
  mutate(power_fit = map(data, ~lm(log(functioning) ~ log(richness), data = .))) %>% 
  mutate(power_fit = map(power_fit, augment)) %>% 
  unnest(cols = c(data, power_fit)) %>% 
  ggplot(aes(x = richness, y = functioning))+
  geom_point(position = position_jitter(width = 0.1, height = 0), 
             alpha = 1, size = 1, colour = "#377EB8")+
  geom_line(aes(x = richness, y = exp(.fitted)), 
            colour = "black", size = 0.7)+
  geom_smooth(method = "lm", se = F, linetype = "dotted", size = 0.7, colour = "darkred")+
  geom_ribbon(aes(x = richness, 
                  ymin = exp(.fitted - 2*.se.fit), 
                  ymax = exp(.fitted + 2*.se.fit),
                  group = environment), fill = "grey", alpha = 0.2)+
  facet_wrap(~environment, scales = "free_y")+
  theme_bw()


```

##BEF metrics

We calculate the slope between richness and functioning for all combinations of environments. 

+ for all scales (1:5 environments)
+ for all possible unique combinations of environments 

We calculate the functioning of a given species mixture in that combination of environemnts at that scale as the average functioning of that species mixture in the single environments. 

For each scale and environment combination we then calculate the following metrics:

+ the **linear slope** of the richness ~ functioning relationship
+ the **slope of a power fit** to the richness ~ functioning relationship
+ **overyielding**: highest mixture value / mean monoculture value
+ **transgressive overyielding**: highest mixture value / maximum monoculture value


```{r, warning=FALSE}

plot_values_wide <- 
plot_values_df %>% 
  spread(environment, functioning)

#calculate average functioning for each env combination at each scale and store results in dataframe
env_values <- 
lapply(env_comb, function(x) { #for all scales (1:5)
  apply(x, 2, function(y) { #for all environmental combinations
   
     df <- data.frame( #average functioning for this environment combination
       env_comb = paste0(y, collapse = " "),
       envnum = length(y),
       richness = plot_values_wide$richness,
       functioning = rowMeans(plot_values_wide[,y])
                     )
  })
  })

env_values <- bind_rows(unlist(env_values, recursive = FALSE))

# calculate BEF metrics for each environment combination
env_metrics <- 
  env_values %>% 
  group_by(env_comb, envnum) %>%
  nest() %>% 
  mutate(linear_fit = map(data, ~lm(functioning ~ richness, data = .))) %>% 
  mutate(linear_fit = map_dbl(linear_fit, function(x) coef(x)[2])) %>%
  #mutate(power_fit = map(data, ~nls(functioning ~ a*richness^b, data = ., start = list(a = 1, b = 1)))) %> 
  #mutate(power_fit = map_dbl(power_fit, function(x) coef(x)[2])) %>% 
  mutate(overyield = map_dbl(data, function(x) {
    x[x$richness == specnum,]$functioning / 
      mean(x[x$richness == 1,]$functioning)
    })) %>% 
  mutate(transgressive = map_dbl(data, function(x) {
    x[x$richness == specnum,]$functioning / 
      max(x[x$richness == 1,]$functioning)})) 

```

### Fig 2a - power-fits 

```{r}
if(Scenario %in% c(1,3)){
Fig_2_a <- 
env_values %>%
  group_by(envnum) %>% 
  nest() %>% 
  mutate(power_fit = map(data, ~nls(functioning ~ a*richness^b, data = ., start = list(a = 1, b = 1)))) %>%
  mutate(power_fit = map(power_fit, augment)) %>% 
  unnest(cols = power_fit) %>% 
  ggplot(aes(x = richness, y = functioning, colour = as.factor(envnum)))+
  geom_point( size = 1, alpha = 1, position = position_dodge(width = 0.7))+
  geom_line(aes(y = .fitted, group = envnum), position = position_dodge(width = 0.7))+
  scale_color_manual(values = viridis(envnum+1)[1:envnum], name = "scale")+
  theme_classic()+
  labs(y = "production", x = "species richness")+
  guides(colour = guide_legend(ncol = 3))+
  theme(legend.position = c(0.85,0.15), 
        legend.background = element_rect(fill = "transparent"),
        axis.ticks.length=unit(-0.25, "cm"),
        axis.text.x = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")),
        axis.text.y = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")))
}

if(Scenario == 2){
Fig_2_a <- 
env_values %>%
  group_by(envnum) %>% 
  nest() %>% 
  mutate(fit = map(data, ~lm(functioning ~ richness, data = .))) %>%
  mutate(fit = map(fit, augment)) %>% 
  unnest(cols = fit) %>% 
  ggplot(aes(x = richness, y = functioning, colour = as.factor(envnum)))+
  geom_point( size = 1, alpha = 1, position = position_dodge(width = 0.7))+
  geom_line(aes(y = .fitted, group = envnum), position = position_dodge(width = 0.7))+
  scale_color_manual(values = viridis(envnum+1)[1:envnum], name = "scale")+
  theme_classic()+
  labs(y = "production", x = "species richness")+
  guides(colour = guide_legend(ncol = 3))+
  theme(legend.position = c(0.85,0.15), 
        legend.background = element_rect(fill = "transparent"),
        axis.ticks.length=unit(-0.25, "cm"),
        axis.text.x = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")),
        axis.text.y = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")))
}

if(Scenario == 3) { #weighted mean
  save("Fig_2_a", file = here("figures", "Fig_2_a.RData"))
  } else if(Scenario == 2) { #mean
    Fig_S2_a <- Fig_2_a
  save("Fig_S2_a", file = here("figures", "Fig_S2_a.RData"))
    } else if(Scenario == 1) { #dominance
      Fig_S2_d <- Fig_2_a
    save("Fig_S2_d", file = here("figures", "Fig_S2_d.RData"))}

```


### power-fit statistics
```{r}
if(Scenario == 3){
env_values %>%
  group_by(envnum) %>% 
  nest() %>% 
  mutate(power_fit = map(data, ~nls(functioning ~ a*richness^b, data = ., start = list(a = 1, b = 1)))) %>% 
  mutate(power_ci = map(power_fit, function(x) confint2(x, "b", level = 0.95))) %>% 
  mutate(power_ci = map(power_ci, function(x) tibble(level = colnames(x), CI = x[c(1:2)]))) %>%
  mutate(power_fit = map(power_fit, tidy)) %>% 
  unnest(cols = power_fit) %>% 
  filter(term == "b") %>%
  unnest(cols = power_ci)
  select(envnum, estimate, p.value) %>% 
  ungroup() %>% 
  mutate_if(is.numeric, round, digits = 3)
}

```

### Fig 2b - overyielding
```{r}
Fig_2_b <- 
env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>%
  filter(metric == "overyield") %>% 
  ggplot(aes(x = envnum, y = value, colour = as.factor(envnum)))+
  geom_point( size = 4, alpha = 1, position = position_jitter(width = 0.1))+
  stat_smooth(method = "lm", se = F, size = 0.5, colour = "darkred")+
  scale_color_manual(values = viridis(envnum+1)[1:envnum], name = "scale")+
  theme_classic()+
  labs(y = "overyielding", x = "scale")+
  theme(legend.position = "none",
        axis.ticks.length=unit(-0.25, "cm"),
        axis.text.x = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")),
        axis.text.y = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")) )+
  NULL

if(Scenario == 3) { #weighted mean
  save("Fig_2_b", file = here("figures", "Fig_2_b.RData"))
  } else if(Scenario == 2) { #mean
    Fig_S2_b <- Fig_2_b
  save("Fig_S2_b", file = here("figures", "Fig_S2_b.RData"))
    } else if(Scenario == 1) { #dominance
      Fig_S2_e <- Fig_2_b
    save("Fig_S2_e", file = here("figures", "Fig_S2_e.RData"))}


Fig_2_b
```

### overyielding statistics
```{r}

env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>%
  filter(metric == "overyield") %>% 
  lm(value ~ envnum, data = .) %>% 
  tidy %>% 
  mutate_if(is.numeric, round, 3)

```

### Fig 2c - transgressive overyielding
```{r}

Fig_2_c <- 
env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>% 
  filter(metric == "transgressive") %>% 
  ggplot(aes(x = envnum, y = value, colour = as.factor(envnum)))+
  geom_point( size = 4, alpha = 1, position = position_jitter(width = 0.1))+
  stat_smooth(method = "lm", se = F, size = 0.5, colour = "darkred")+
  scale_color_manual(values = viridis(envnum+1)[1:envnum], name = "scale")+
  theme_classic()+
  labs(y = "transgressive overyielding", x = "scale")+
  theme(legend.position = "none",
        axis.ticks.length=unit(-0.25, "cm"),
        axis.text.x = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")),
        axis.text.y = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")) )+
  #coord_fixed(ratio = 2/0.2)+
  NULL


if(Scenario == 3) { #weighted mean
  save("Fig_2_c", file = here("figures", "Fig_2_c.RData"))
  } else if(Scenario == 2) { #mean
    Fig_S2_c <- Fig_2_c
  save("Fig_S2_c", file = here("figures", "Fig_S2_c.RData"))
    } else if(Scenario == 1) { #dominace
      Fig_S2_f <- Fig_2_c
    save("Fig_S2_f", file = here("figures", "Fig_S2_f.RData"))}

Fig_2_c
```


### transgressive overyielding - statistics
```{r}
env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>%
  filter(metric == "transgressive") %>% 
  lm(value ~ envnum, data = .) %>% 
  tidy %>% 
  mutate_if(is.numeric, round, 3)

```


# multiple draws from uniform

In the above example with took a single draw for the trait values from the uniform distribution. In the code below, we repeat this 500 times to get a distribution of BEF results from multiple draws

## fitness values
```{r}
Traits <- matrix(
  nrow = length(env),
  ncol = length(spec),
  dimnames = list(env, spec))


# take N random draws

N <- 1000

Trait_list <- 
lapply(1:N, function(x) {Traits[1:nrow(Traits), 1:ncol(Traits)] <-
  runif( n = prod( dim( Traits)), 0, 1)
return(Traits)})



```


##plot values
```{r}

# choose scenario

# 1 = Dominance
# 2 = Mean
# 3 = Weighted mean


Scenario <- 3

plot_values_df_list <- 
pblapply(Trait_list, function(TM) {

plot_values <- sapply(env, #for each environment
                      function(x) {
                        lapply(spec_comb, #for each richness level
                               function(y) {
                                 apply(y, 2, function(z){ #for each species combination
                                   if(Scenario == 1){
                                     max(TM[x,z])
                                     } else if(Scenario == 2){
                                     mean(TM[x,z])
                                       } else {
                                         mean(sum(TM[x,z]^2) / abs(sum(TM[x,z])))
                                       } 
                                   }
                                   )
                                 }
                               )
                        }
                      )


plot_values_df <- 
  tibble(
    richness = rep( rep(1:specnum, unlist(lapply(spec_comb, ncol))), envnum),
    spec_comb = rep(lapply(spec_comb, 
                           function(x) apply(x, 2, function(y) 
                             paste(y, collapse = " "))) %>% unlist(),
                    envnum),
    environment = rep(env, each = sum(choose(specnum,1:specnum))),
    functioning = unlist(plot_values)
    )

return(plot_values_df)
})
```


##BEF metrics
```{r}

env_metrics_list <- 
  pblapply(plot_values_df_list, function(PV) {
    
    plot_values_wide <-
      PV %>% 
      spread(environment, functioning)

#calculate average functioning for each env combination at each scale and store results in dataframe
env_values <- 
lapply(env_comb, function(x) { #for all scales (1:5)
  apply(x, 2, function(y) { #for all environmental combinations
   
     df <- data.frame( #average functioning for this environment combination
       env_comb = paste0(y, collapse = " "),
       envnum = length(y),
       richness = plot_values_wide$richness,
       functioning = rowMeans(plot_values_wide[,y]),
       stringsAsFactors = FALSE
                     )
  })
  })

env_values <- bind_rows(unlist(env_values, recursive = FALSE))

# calculate BEF metrics for each environment combination
env_metrics <- 
  env_values %>% 
  group_by(env_comb, envnum) %>%
  nest() %>% 
  mutate(overyield = map_dbl(data, function(x) {
    x[x$richness == specnum,]$functioning / 
      mean(x[x$richness == 1,]$functioning)
    })) %>% 
  mutate(transgressive = map_dbl(data, function(x) {
    x[x$richness == specnum,]$functioning / 
      max(x[x$richness == 1,]$functioning)})) 


overyield <- 
env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>%
  filter(metric == "overyield") %>% 
  lm(value ~ envnum, data = .) %>% 
  coef %>% 
  `[`(2)


transgressive <- 
env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>%
  filter(metric == "transgressive") %>% 
  lm(value ~ envnum, data = .) %>% 
   coef %>% 
  `[`(2)

beta_slopes <- 
env_values %>% 
  group_by(envnum, env_comb) %>%
  nest() %>% 
  mutate(power_fit = map(data, ~nls(functioning ~ a*richness^b, data = ., start = list(a = 1, b = 1)))) %>% 
  mutate(beta = map_dbl(power_fit, function(x) coef(x)[2])) %>% 
  lm(beta~envnum, data = .) %>% 
  coef %>% 
  `[`(2)
  
  

return(tibble(overyield = overyield, 
              transgressive = transgressive,
              beta_slopes = beta_slopes))
    
    
  })


```

```{r}
Results <- 
bind_rows(env_metrics_list)
```

```{r}
p <- 
Results %>% 
  gather(metric, value) %>% 
  mutate(metric = factor(metric,  labels = c("beta slopes", "overyielding", "transgressive\noveryielding"))) %>% 
  ggplot(aes(x = value, fill = metric))+
  geom_histogram(binwidth = 0.005)+
  facet_wrap(~metric)+
  geom_vline(xintercept = 0, linetype = "dashed")+
  theme_bw()+
  scale_fill_brewer(palette = "Set1")+
  theme(legend.position = "none")+
  labs(y = paste("n out of", N, "draws", sep = " "),
       title = "change in production ~ richness relationship with scale")

ggsave(plot = p, filename = here("figures", "Fig_S1.pdf"), width = 6, height = 3)

p
```

