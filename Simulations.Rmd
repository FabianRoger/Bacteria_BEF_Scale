---
title: "Bacterial EF across Scale - Simulations"
output: html_notebook
---

```{r, message=FALSE}
library(dplyr)
library(tidyr)
library(purrr)
library(ggplot2)
library(ggbeeswarm)
library(broom)
library(viridis)
library(here)
library(pbapply)
library(nlstools)
```

This script exports: 

+ the subplots for Figure 2
+ the subplots for Figure S3
+ Figure S1

See script `Multipanel_Fig_2.Rmd` for the assemblage and export of figure 2. 

To generate the subplots for Figure S3, the `Scenario` Variable (line 135) has to be set to `1` and `2` respectively, and the code from line 135 to line 420 has to be run with these values respectively. Figure S3 is then assembled and exported from the same script as Figure 2. 

make folder to export figures
```{r}

if(! dir.exists(here("figures"))){
  dir.create(here("figures"))
}

```


#set up simulations

+ We want to simulate 5 strains of Bacteria, growing in 5 different environments. 
+ Each Strain differs in its ability to grow on each antibiotic.
+ We grow the bacteria in every possible combination (monocultures and all possible species mixtures)
+ We grow them on every possible combination of environments
+ We measure EF at different scales going from 1 to 5 environments  

define number of species and environments
```{r}

specnum <- 5
envnum <- 5
 
```

## strains

We create 5 species (for `specnum = 5`) named strain_1 to strain_5 and get every possible combination of the five species for all 1,2,3,4 and 5 species combination (corresponding richness levels 1:5 in a biodiversity experiment)

```{r}
spec <- paste("strain_", c(1:specnum), sep = "")
spec_comb <- sapply(c(1:specnum), function(x) combn(spec, x)) 
names(spec_comb) <- paste("richness", c(1:specnum))
```

## environments

We create 5 environments (for `envnum = 5`) named Environment_1 to Environment_5 and get every possible combination of the five environments for all 1,2,3,4 and 5 environment combinations (corresponding to the different scales)

```{r}
env <- paste("Environment_", c(1:envnum), sep = "")
env_comb <- sapply(c(1:envnum), function(x) combn(env, x)) 
names(env_comb) <- paste("Heterogeneity", c(1:envnum))
```

number of combinations

```{r}
tibble(spec_combs = 
         sum(choose(specnum,1:specnum)),
       env_combs = 
         sum(choose(envnum,1:envnum)))
```

## fitness values

We assign each strain a fitness value for each environment. The values are drawn from a uniform distribution (0,1) for each strain and each environment. 

```{r}

set.seed(1346)

Traits <- matrix(
  nrow = length(env),
  ncol = length(spec),
  dimnames = list(env, spec))


Traits[1:nrow(Traits), 1:ncol(Traits)] <-
  runif( n = prod( dim( Traits)), 0, 1)

Traits
```

#run simulations

##plot values

here we calculate the outcome (biomass / 'functioning') of every species combination in each environment. We calculate the mixture performance in three different ways:

1) **Dominance**: The mixture value equals the performance of the best performing species 
2) **Mean**: The mixture value equals the mean of the performances of all species 

3) **Weighted mean**: The mixture value equals the mean performance of all species, weighted by their relative performance in the environment

**we present the weighted mean in the main article**

*what the code does*

for each environment `sapply(env, ...` it cycles through all richness levels `lapply(spec_comb, ...)` and for each richness level it cycles through all species combinations `apply(..., 2, )`.
Then it calculates the mixture performance of that species combination of that richness level in that environment given the species performance stored in `Traits` and given the rules in the chosen `Scenario`

Choosing Scenario = 3 produces the results in the main text and the subplots for Figure 2
Choosing Scenario = 1 & 2 produces the subplots for supplemantary Figure S1

```{r}

# choose scenario

# 1 = Dominance
# 2 = Mean
# 3 = Weighted mean


Scenario <- 3

plot_values <- sapply(env, #for each environment
                      function(x) {
                        lapply(spec_comb, #for each richness level
                               function(y) {
                                 apply(y, 2, function(z){ #for each species combination
                                   if(Scenario == 1){
                                     max(Traits[x,z])
                                     } else if(Scenario == 2){
                                     mean(Traits[x,z])
                                       } else {
                                         mean(sum(Traits[x,z]^2) / abs(sum(Traits[x,z])))
                                       } 
                                   }
                                   )
                                 }
                               )
                        }
                      )


plot_values_df <- 
  tibble(
    richness = rep( rep(1:specnum, unlist(lapply(spec_comb, ncol))), envnum),
    spec_comb = rep(lapply(spec_comb, 
                           function(x) apply(x, 2, function(y) 
                             paste(y, collapse = " "))) %>% unlist(),
                    envnum),
    environment = rep(env, each = sum(choose(specnum,1:specnum))),
    functioning = unlist(plot_values)
    )

#small random error so that the function fitting functions don't fail

# plot_values_df <- 
#   plot_values_df %>% 
#   mutate(functioning = functioning + rnorm(n(), 0, 0.01)) %>% 
#   mutate(functioning = functioning + abs(min(functioning)) + 0.01)

```

### plot plot-values

Here we plot the single species and mixture functioning of each species combination in each environment. The Mixture performance is calculated as the weighted mean of the monoculture performances. 

We show a power-fit (with 2*se CI) and a linear fit, both showing the positive richness ~ functioning relationship (that follows inherently from the way we calculate the mixture values)

```{r}

plot_values_df %>% 
  na.omit() %>% 
  group_by(environment) %>%
  nest() %>% 
  mutate(power_fit = map(data, ~lm(log(functioning) ~ log(richness), data = .))) %>% 
  mutate(power_fit = map(power_fit, augment, se_fit = TRUE)) %>% 
  unnest(cols = c(data, power_fit)) %>% 
  ggplot(aes(x = richness, y = functioning))+
  geom_point(position = position_jitter(width = 0.1, height = 0), 
             alpha = 1, size = 1, colour = "#377EB8")+
  geom_line(aes(x = richness, y = exp(.fitted)), 
            colour = "black", size = 0.7)+
  geom_smooth(method = "lm", se = F, linetype = "dotted", size = 0.7, colour = "darkred")+
  geom_ribbon(aes(x = richness, 
                  ymin = exp(.fitted - 2*.se.fit), 
                  ymax = exp(.fitted + 2*.se.fit),
                  group = environment), fill = "grey", alpha = 0.2)+
  facet_wrap(~environment, scales = "free_y")+
  theme_bw()

```

##BEF metrics

We calculate the slope between richness and functioning for all combinations of environments. 

+ for all scales (1:5 environments)
+ for all possible unique combinations of environments 

We calculate the functioning of a given species mixture in that combination of environments at that scale as the average functioning of that species mixture in the single environments. 

For each scale and environment combination we then calculate the following metrics:

+ the **linear slope** of the richness ~ functioning relationship
+ the **slope of a power fit** to the richness ~ functioning relationship
+ **overyielding**: highest mixture value / mean monoculture value
+ **transgressive overyielding**: highest mixture value / maximum monoculture value


```{r, warning=FALSE}

plot_values_wide <- 
plot_values_df %>% 
  spread(environment, functioning)

#calculate average functioning for each env combination at each scale and store results in dataframe
env_values <- 
lapply(env_comb, function(x) { #for all scales (1:5)
  apply(x, 2, function(y) { #for all environmental combinations
   
     df <- data.frame( #average functioning for this environment combination
       env_comb = paste0(y, collapse = " "),
       envnum = length(y),
       richness = plot_values_wide$richness,
       functioning = rowMeans(plot_values_wide[,y]) #mean of functioning across environments
       #functioning = rowSums(plot_values_wide[,y]) #sum of functioning across environments
                     )
  })
  })

env_values <- bind_rows(unlist(env_values, recursive = FALSE))

# calculate BEF metrics for each environment combination
env_metrics <- 
  env_values %>% 
  group_by(env_comb, envnum) %>%
  nest() %>% 
  mutate(linear_fit = map(data, ~lm(functioning ~ richness, data = .))) %>% 
  mutate(linear_fit = map_dbl(linear_fit, function(x) coef(x)[2])) %>%
  mutate(power_fit = map(data, ~nls(functioning ~ a*richness^b, data = ., start = list(a = 1, b = 1)))) %>%
  mutate(power_fit = map_dbl(power_fit, function(x) coef(x)[2])) %>%
  mutate(MichMent = map(data, ~nls(functioning ~ a*richness/(b+richness), 
                                   data = ., start = list(a = 1, b = 1)))) %>%
  mutate(MichMent = map_dbl(MichMent, function(x) coef(x)[2])) %>% 
  mutate(overyield = map_dbl(data, function(x) {
    x[x$richness == specnum,]$functioning / 
      mean(x[x$richness == 1,]$functioning)
    })) %>% 
  mutate(transgressive = map_dbl(data, function(x) {
    x[x$richness == specnum,]$functioning / 
      max(x[x$richness == 1,]$functioning)})) 
```

### Fig - power-fits 

```{r}
if(Scenario %in% c(1,3)){
Fig_2_a <- 
env_values %>%
  group_by(env_comb, envnum) %>% 
  nest() %>% 
  mutate(power_fit = map(data, ~nls(functioning ~ a*richness^b, data = ., start = list(a = 1, b = 1)))) %>%
  #mutate(power_fit = map(data, ~nls(functioning ~ a*richness/(b+richness), data = ., start = list(a = 1, b = 1)))) %>%
  mutate(power_fit = map(power_fit, augment)) %>% 
  unnest(cols = power_fit) %>% 
  ggplot(aes(x = richness, y = functioning, colour = as.factor(envnum)))+
  geom_point(aes(group = env_comb), 
             size = 1, alpha = 1, 
              position = position_dodge(width = 0.7)
              )+
  geom_line(#aes(group = env_comb),
            aes(y = .fitted, group = env_comb),
            position = position_dodge(width = 0.7)
            )+
  facet_wrap(~envnum)+
  scale_color_manual(values = viridis(envnum+1)[1:envnum], name = "scale")+
  theme_classic()+
  labs(y = "production", x = "species richness")+
  #guides(colour = guide_legend(ncol = 3))+
  theme(legend.position = "none")
  # theme(legend.position = c(0.85,0.15), 
  #       legend.background = element_rect(fill = "transparent"),
  #       axis.ticks.length=unit(-0.25, "cm"),
  #       axis.text.x = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")),
  #       axis.text.y = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")))
}

if(Scenario == 2){
Fig_2_a <- 
env_values %>%
  group_by(envnum) %>% 
  nest() %>% 
  mutate(fit = map(data, ~lm(functioning ~ richness, data = .))) %>%
  mutate(fit = map(fit, augment)) %>% 
  unnest(cols = fit) %>% 
  ggplot(aes(x = richness, y = functioning, colour = as.factor(envnum)))+
  geom_point( size = 1, alpha = 1, position = position_dodge(width = 0.7))+
  geom_line(aes(y = .fitted, group = envnum), position = position_dodge(width = 0.7))+
  scale_color_manual(values = viridis(envnum+1)[1:envnum], name = "scale")+
  theme_classic()+
  labs(y = "production", x = "species richness")+
  guides(colour = guide_legend(ncol = 3))+
  theme(legend.position = c(0.85,0.15), 
        legend.background = element_rect(fill = "transparent"),
        axis.ticks.length=unit(-0.25, "cm"),
        axis.text.x = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")),
        axis.text.y = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")))
}

```


### power-fit statistics
```{r}
if(Scenario == 3){
env_values %>%
  group_by(envnum) %>% 
  nest() %>% 
  mutate(power_fit = map(data, ~nls(functioning ~ a*richness^b, data = ., start = list(a = 1, b = 1)))) %>% 
  mutate(power_ci = map(power_fit, function(x) confint2(x, "b", level = 0.95))) %>% 
  mutate(power_ci = map(power_ci, function(x) tibble(level = colnames(x), CI = x[c(1:2)]))) %>%
  mutate(power_fit = map(power_fit, tidy)) %>% 
  unnest(cols = power_fit) %>% 
  filter(term == "b") %>%
  unnest(cols = power_ci) %>% 
  select(envnum, estimate, p.value, level, CI) %>% 
  ungroup() %>% 
  mutate_if(is.numeric, round, digits = 3)
}

```
### Fig - power-fits by scale

```{r}

Fig_2_a <- 
env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>%
  filter(metric == "power_fit") %>% 
  #filter(metric == "MichMent") %>% 
  ggplot(aes(x = envnum, y = value))+#, colour = as.factor(envnum)))+
  geom_point( size = 2, alpha = 1, position = position_jitter(width = 0.1), colour = viridis(6)[3])+
  stat_smooth(method = "lm", se = F, size = 0.5, colour = "darkred", linetype = "dashed")+
 # scale_color_manual(values = viridis(envnum+1)[1:envnum], name = "scale")+
  theme_classic()+
  labs(y = "beta_slopes", x = "scale")+
  theme(legend.position = "none",
        axis.ticks.length=unit(-0.25, "cm"),
        axis.text.x = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")),
        axis.text.y = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")) )+
  scale_y_continuous(limits = c(0,0.26))
  NULL


```

### beta statistics
```{r}

env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>%
  filter(metric == "power_fit") %>% 
  lm(value ~ envnum, data = .) %>% 
  tidy %>% 
  mutate_if(is.numeric, round, 3)

```

### Fig - overyielding
```{r}
Fig_2_b <- 
env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>%
  filter(metric == "overyield") %>% 
  ggplot(aes(x = envnum, y = value, colour = as.factor(envnum)))+
  geom_point( size = 4, alpha = 1, position = position_jitter(width = 0.1))+
  stat_smooth(method = "lm", se = F, size = 0.5, colour = "darkred")+
  scale_color_manual(values = viridis(envnum+1)[1:envnum], name = "scale")+
  theme_classic()+
  labs(y = "overyielding", x = "scale")+
  theme(legend.position = "none",
        axis.ticks.length=unit(-0.25, "cm"),
        axis.text.x = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")),
        axis.text.y = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")) )+
  NULL

```

### overyielding statistics
```{r}

env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>%
  filter(metric == "overyield") %>% 
  lm(value ~ envnum, data = .) %>% 
  tidy %>% 
  mutate_if(is.numeric, round, 3)

```

### Fig - transgressive overyielding
```{r}

Fig_2_c <- 
env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>% 
  filter(metric == "transgressive") %>% 
  ggplot(aes(x = envnum, y = value))+#, colour = as.factor(envnum)))+
  geom_point( size = 2, alpha = 1, position = position_jitter(width = 0.1), colour = viridis(6)[3])+
  stat_smooth(method = "lm", se = F, size = 0.5, colour = "darkred")+
 # scale_color_manual(values = viridis(envnum+1)[1:envnum], name = "scale")+
  theme_classic()+
  labs(y = "transgressive overyielding", x = "scale")+
  theme(legend.position = "none",
        axis.ticks.length=unit(-0.25, "cm"),
        axis.text.x = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")),
        axis.text.y = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")) )+
  scale_y_continuous(limits = c(0, 1.1))+
  #coord_fixed(ratio = 2/0.2)+
  NULL


if(Scenario == 3) { #weighted mean
  save("Fig_2_c", file = here("figures", "Fig_2_c.RData"))
  } else if(Scenario == 2) { #mean
    Fig_S3_c <- Fig_2_c
  save("Fig_S3_c", file = here("figures", "Fig_S3_c.RData"))
    } else if(Scenario == 1) { #dominace
      Fig_S3_f <- Fig_2_c
    save("Fig_S3_f", file = here("figures", "Fig_S3_f.RData"))}

Fig_2_c
```



# multiple draws from uniform

In the above example with took a single draw for the trait values from the uniform distribution. In the code below, we repeat this 1000 times to get a distribution of BEF results from multiple draws

### fitness values
```{r}
Traits <- matrix(
  nrow = length(env),
  ncol = length(spec),
  dimnames = list(env, spec))


# take N random draws

N <- 1000

Trait_list <- 
lapply(1:N, function(x) {Traits[1:nrow(Traits), 1:ncol(Traits)] <-
  runif( n = prod( dim( Traits)), 0, 1)
return(Traits)})

```


###plot values
```{r}

# choose scenario

# 1 = Dominance
# 2 = Mean
# 3 = Weighted mean


Scenario <- 3

plot_values_df_list <- 
pblapply(Trait_list, function(TM) {

plot_values <- sapply(env, #for each environment
                      function(x) {
                        lapply(spec_comb, #for each richness level
                               function(y) {
                                 apply(y, 2, function(z){ #for each species combination
                                   if(Scenario == 1){
                                     max(TM[x,z])
                                     } else if(Scenario == 2){
                                     mean(TM[x,z])
                                       } else {
                                         mean(sum(TM[x,z]^2) / abs(sum(TM[x,z])))
                                       } 
                                   }
                                   )
                                 }
                               )
                        }
                      )


plot_values_df <- 
  tibble(
    richness = rep( rep(1:specnum, unlist(lapply(spec_comb, ncol))), envnum),
    spec_comb = rep(lapply(spec_comb, 
                           function(x) apply(x, 2, function(y) 
                             paste(y, collapse = " "))) %>% unlist(),
                    envnum),
    environment = rep(env, each = sum(choose(specnum,1:specnum))),
    functioning = unlist(plot_values)
    )

return(plot_values_df)
})
```


###BEF metrics
```{r}

env_metrics_list <- 
  pblapply(plot_values_df_list, function(PV) {
    
    plot_values_wide <-
      PV %>% 
      spread(environment, functioning)

#calculate average functioning for each env combination at each scale and store results in dataframe
env_values <- 
lapply(env_comb, function(x) { #for all scales (1:5)
  apply(x, 2, function(y) { #for all environmental combinations
   
     df <- data.frame( #average functioning for this environment combination
       env_comb = paste0(y, collapse = " "),
       envnum = length(y),
       richness = plot_values_wide$richness,
       functioning = rowMeans(plot_values_wide[,y]),
       stringsAsFactors = FALSE
                     )
  })
  })

env_values <- bind_rows(unlist(env_values, recursive = FALSE))

# calculate BEF metrics for each environment combination
env_metrics <- 
  env_values %>% 
  group_by(env_comb, envnum) %>%
  nest() %>% 
  mutate(overyield = map_dbl(data, function(x) {
    x[x$richness == specnum,]$functioning / 
      mean(x[x$richness == 1,]$functioning)
    })) %>% 
  mutate(transgressive = map_dbl(data, function(x) {
    x[x$richness == specnum,]$functioning / 
      max(x[x$richness == 1,]$functioning)})) 


# overyield <- 
# env_metrics %>% 
#   select(-data) %>% 
#   gather(metric, value, -envnum, -env_comb) %>%
#   filter(metric == "overyield") %>% 
#   lm(value ~ envnum, data = .) %>% 
#   coef %>% 
#   `[`(2)


transgressive <- 
env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>%
  filter(metric == "transgressive") %>% 
  lm(value ~ envnum, data = .)# %>% 
  # coef %>% 
 # `[`(2)

beta_slopes <- 
env_values %>% 
  group_by(envnum, env_comb) %>%
  nest() %>% 
  mutate(power_fit = map(data, ~nls(functioning ~ a*richness^b, data = ., start = list(a = 1, b = 1)))) %>%
  mutate(beta = map_dbl(power_fit, function(x) coef(x)[2])) %>%
  lm(beta~envnum, data = .) #%>% 
 # coef %>% 
 # `[`(2)

# MichMent <- 
# env_values %>% 
#   group_by(envnum, env_comb) %>%
#   nest() %>% 
#   mutate(MichMent = map(data, ~nls(functioning ~ a*richness/(b+richness),
#                                    data = ., start = list(a = 1, b = 1)))) %>%
#   mutate(MichMent = map_dbl(MichMent, function(x) coef(x)[2])) %>%
#   lm(MichMent~envnum, data = .) %>% 
#   coef %>% 
#   `[`(2)
#   
  

return(tibble(#overyield = overyield, 
              transgressive = list(transgressive),
              beta_slopes = list(beta_slopes)#,
             # MichMent = MichMent
              ))
    
    
  })


```

```{r}
Results <- 
 bind_rows(env_metrics_list) %>% 
  gather(metric, value) %>% 
  mutate(slope = map_dbl(map(.$value, coef),"envnum")) %>% 
  mutate(Intercept = map_dbl(map(.$value, coef),"(Intercept)")) %>% 
  select(-value)
```

##Fig 2 - slopes and histograms 

###Fig 2a - inset
```{r}

library(RColorBrewer)
col_2 <- viridis(6)[3]

quantile_res <- 
Results %>% 
  filter(metric == "beta_slopes") %>% 
  pull(slope) %>% 
  quantile(probs = c(0.025, 0.5, 0.975))


Fig_2_a_i <- 
Results %>% 
  filter(metric == "beta_slopes") %>% 
  ggplot(aes(x = slope))+
  geom_histogram(binwidth = 0.001, fill = col_2)+
  geom_vline(xintercept = 0, linetype = "dashed")+
  annotate(geom = "point", x = quantile_res[2], y = 10)+
  annotate(geom = "errorbarh", xmax = quantile_res[1], 
           xmin = quantile_res[3], y = 10)+
  #geom_point(data = . %>% summarise(beta_slopes = median(beta_slopes)), aes(x = beta_slopes, y = 50))+
  theme_bw()+
  theme(legend.position = "none")+
  labs(y = paste("n out of", N, "draws", sep = " "),
       title = "change in production ~ richness relationship with scale",
       x = "")
  

if(Scenario == 3){
  save("Fig_2_a_i", file = here("figures", "Fig_2_a_i.RData"))
  #ggsave(plot = p, filename = here("figures", "Fig_2a(i).pdf"), width = 6, height = 3)
}


Fig_2_a_i

```

###Fig 2a
```{r}
env_pred = seq(1,5,0.1)

newdata = tibble(rep = rep(1:nrow(Results), each = length(env_pred)),
                 env_pred = rep(env_pred, nrow(Results)))

Results_pred <- 
  Results %>% 
  mutate(rep = 1:n()) %>% 
  left_join(newdata) %>% 
  mutate(predict = slope*env_pred+Intercept)
 
med_slope <- 
Results %>% 
  mutate(rep = 1:n()) %>% 
  filter(metric == "beta_slopes") %>% 
  slice(1:999) %>% #has to be odd number to find exact media
  mutate(slope_q = 
  case_when(abs(slope - median(slope)) == min(abs(slope - median(slope))) ~ "median",
            abs(slope - quantile(slope, 0.025)) == min( abs(slope - quantile(slope, 0.025))) ~ "low_q",
            abs(slope - quantile(slope, 0.975)) == min( abs(slope - quantile(slope, 0.975))) ~ "high_q")) %>% 
  filter(!is.na(slope_q))

Results_beta <- 
Results_pred %>% 
  filter(metric == "beta_slopes")  

Fig_2_a <- 
  ggplot(Results_beta, aes(x = env_pred, y = predict, group = rep))+
  geom_line(size = 0.5, alpha = 0.1, colour = col_2)+
  geom_line(data = Results_beta %>% filter(rep == pull(filter(med_slope,
                                                   slope_q == "median"), rep)), 
            colour = "darkred", size = 1)+
  theme_classic()+
  labs(y = "beta slopes", x = "scale")+
  theme(legend.position = "none",
        axis.ticks.length=unit(-0.25, "cm"),
        axis.text.x = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")),
        axis.text.y = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")) )+
  scale_y_continuous(limits = c(-0.2, NA))


  
save("Fig_2_a", file = here("figures", "Fig_2_a.RData"))

Fig_2_a

```



##Fig 2b inset
```{r}

quantile_res <- 
Results %>% 
  filter(metric == "transgressive") %>% 
  pull(slope) %>% 
  quantile(probs = c(0.025, 0.5, 0.975))

Results_trans <- 
  Results %>% 
  filter(metric == "transgressive") 

Fig_2_b_i <- 
ggplot(Results_trans, aes(x = slope))+
  geom_histogram(binwidth = 0.006, fill = col_2)+
  geom_vline(xintercept = 0, linetype = "dashed")+
  annotate(geom = "point", x = quantile_res[2], y = 6)+
  annotate(geom = "errorbarh", 
           xmax = quantile_res[1], 
           xmin = quantile_res[3],
           y = 6)+
  theme_bw()+
  theme(legend.position = "none")+
  labs(y = paste("n out of", N, "draws", sep = " "),
       title = "change in transgressive overyielding with scale",
       x = "transgressive overyileding ~ scale")+
  scale_x_continuous(limits = c(-0.07, 0.157))


if(Scenario == 3){
   save("Fig_2_b_i", file = here("figures", "Fig_2_b_i.RData"))
 # ggsave(plot = p, filename = here("figures", "Fig_2b(i).pdf"), width = 6, height = 3)
}


Fig_2_b_i
```

###Fig 2b
```{r}
med_slope <- 
Results %>% 
  mutate(rep = 1:n()) %>% 
  filter(metric == "transgressive")  %>% 
  slice(1:999) %>% #has to be odd number to find exact media
  mutate(slope_q = 
  case_when(abs(slope - median(slope)) == min(abs(slope - median(slope))) ~ "median",
            abs(slope - quantile(slope, 0.025)) == min( abs(slope - quantile(slope, 0.025))) ~ "low_q",
            abs(slope - quantile(slope, 0.975)) == min( abs(slope - quantile(slope, 0.975))) ~ "high_q")) %>% 
  filter(!is.na(slope_q))


Results_trans <- 
Results_pred %>% 
  filter(metric == "transgressive")  

Fig_2_b <- 
ggplot(Results_trans, aes(x = env_pred, y = predict, group = rep))+
  geom_line(size = 0.5, alpha = 0.1, colour = col_2ai)+
  geom_line(data = Results_trans %>% filter(rep == pull(filter(med_slope, slope_q == "median"), rep)), colour = "darkred", size = 1)+
  theme_classic()+
  labs(y = "beta slopes", x = "scale")+
  theme(legend.position = "none",
        axis.ticks.length=unit(-0.25, "cm"),
        axis.text.x = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")),
        axis.text.y = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")) )+
  scale_y_continuous(limits = c(-0.2, NA))


save("Fig_2_b", file = here("figures", "Fig_2_b.RData"))


Fig_2_b  
```

##Fig S8 - species specialisation

This code investigates the relationship between transgressive overyielding and the species specialization index 
```{r}
Species_specialisation <- 
  lapply(Trait_list, function(x) {
    apply(x, 1, function(y){
      which(y == max(y))
    })
  }) %>% 
  lapply(., function(x) {
    ssp <- length(unique(x))/length(x)
    (ssp-(1/envnum))/(1-(1/envnum))
}) %>% unlist()

sppT <-   
tibble(spec_spec = Species_specialisation, 
       transgressive = filter(Results, metric == "transgressive")$slope)

ggplot(sppT, aes(x = spec_spec, y = transgressive))+
  geom_beeswarm(shape = 21, fill = NA, colour = "#2ca25f")+
  geom_smooth(se = FALSE, method = "lm", colour = "black", size = 0.5)+
  theme_bw()+
  labs(x = "species specialisation index", y = expression(scale - OY[trans]-slope))

if(Scenario == 3){
ggsave(filename = here("figures", "Fig_S8.pdf"), width = 6, height = 4)
}

```


### statistic

```{r}

sppT %>% 
  lm(transgressive~spec_spec, data = .) %>% 
  tidy()

```

