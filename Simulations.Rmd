---
title: "Bacterial EF across Scale - Simulations"
output: html_notebook
---

```{r, message=FALSE}
library(dplyr)
#library(tibble)
library(tidyr)
library(purrr)
library(ggplot2)
library(broom)
#library(raster) (for now only needed for last visualization)
library(akima)
library(RColorBrewer)
library(viridis)
library(here)
library(ggsci)
library(pbapply)
```

#set up simulations

+ We want to simulate 5 strains of Bacteria, growing in 5 different environments. 
+ Each Strain differs in it's ability to grow on each antibiotic.
+ We grow the bacteria in every possible combination (monocultures and all possibel 2 to 5 species mixtures)
+ We grow them on every possible combination of environments (1 antibiotics to 4 antibiotics + control)
+ We measure EF at different scales going from 1 to 5 environments  

define number of species and environments
```{r}

specnum <- 5
envnum <- 5
 
```

## strains

We create 5 species (for `specnum = 5`) named strain_1 to strain_5 and get every possible combination of the five species for all 1,2,3,4 and 5 species combination (corresponding richness levles 1:5 in a biodiversity experiment)

```{r}
spec <- paste("strain_", c(1:specnum), sep = "")
spec_comb <- sapply(c(1:specnum), function(x) combn(spec, x)) 
names(spec_comb) <- paste("richness", c(1:specnum))
```

## environments

We create 5 environments (for `envnum = 5`) named Environment_1 to Environment_5 and get every possible combination of the five environments for all 1,2,3,4 and 5 environment combinations (corresponding to the different scales)

```{r}
env <- paste("Environment_", c(1:envnum), sep = "")
env_comb <- sapply(c(1:envnum), function(x) combn(env, x)) 
names(env_comb) <- paste("Heterogeneity", c(1:envnum))
```

number of combinations

```{r}
tibble(spec_combs = 
         sum(choose(specnum,1:specnum)),
       env_combs = 
         sum(choose(envnum,1:envnum)))
```

## fitness values

We assign each strain a fitness value for each environment. The values are drawn from a uniform distrubtion (0,1) for each strain and each environment. 

```{r}

set.seed(1346)

Traits <- matrix(
  nrow = length(env),
  ncol = length(spec),
  dimnames = list(env, spec))


Traits[1:nrow(Traits), 1:ncol(Traits)] <-
  runif( n = prod( dim( Traits)), 0, 1)

Traits
```

#run simulations

##plot values

here we calculate the outcome (biomass / 'functioning') of every species combination in each environment. We calculate the mixture performance in three differen ways:

1) **Dominance**: The mixture value equals the perfomance of the best performing species 
2) **Mean**: The mixture value equals the mean of the performances of all species 

3) **Weighted mean**: The mixture value equals the mean performance of all species, weighted by their relative performance in the environemnt

**we present the wighted mean in the main article**

*what the code does*

for each environment `sapply(env, ...` it cycles through all richness levels `lapply(spec_comb, ...)` and for each richness level it cycles through all species combinations `apply(..., 2, )`.
Then it calculates the the mixture performance of that species combination of that richness level in that environment given the species performance stored in `Traits` and given the rules given by the chosen `Scenario`

MAYBE? We also add a small random error to the results for the curve fitting not to fail.

```{r}

# choose scenario

# 1 = Dominance
# 2 = Mean
# 3 = Weighted mean


Scenario <- 3

plot_values <- sapply(env, #for each environment
                      function(x) {
                        lapply(spec_comb, #for each richness level
                               function(y) {
                                 apply(y, 2, function(z){ #for each species combination
                                   if(Scenario == 1){
                                     max(Traits[x,z])
                                     } else if(Scenario == 2){
                                     mean(Traits[x,z])
                                       } else {
                                         mean(sum(Traits[x,z]^2) / abs(sum(Traits[x,z])))
                                       } 
                                   }
                                   )
                                 }
                               )
                        }
                      )


plot_values_df <- 
  tibble(
    richness = rep( rep(1:specnum, unlist(lapply(spec_comb, ncol))), envnum),
    spec_comb = rep(lapply(spec_comb, 
                           function(x) apply(x, 2, function(y) 
                             paste(y, collapse = " "))) %>% unlist(),
                    envnum),
    environment = rep(env, each = sum(choose(specnum,1:specnum))),
    functioning = unlist(plot_values)
    )

#small random error so that the function fitting functions don't fail

# plot_values_df <- 
#   plot_values_df %>% 
#   mutate(functioning = functioning + rnorm(n(), 0, 0.01)) %>% 
#   mutate(functioning = functioning + abs(min(functioning)) + 0.01)

```

### plot plot-values

Here we plot the single species and mixture functioning of each species combination in each environment. The Mixture perfomrmance is calculated as the weighte dmean of the monoculture performances. 

We show a power-fit (with 2*se CI) and a linear fit, both showing the positive richness ~ functioning relationship (that follows inherently from the way we calculate the mixture values)

```{r}

plot_values_df %>% 
  na.omit() %>% 
  group_by(environment) %>%
  nest() %>% 
  mutate(power_fit = map(data, ~lm(log(functioning) ~ log(richness), data = .))) %>% 
  mutate(power_fit = map(power_fit, augment)) %>% 
  unnest(cols = c(data, power_fit)) %>% 
  ggplot(aes(x = richness, y = functioning))+
  geom_point(position = position_jitter(width = 0.1, height = 0), 
             alpha = 1, size = 1, colour = "#377EB8")+
  geom_line(aes(x = richness, y = exp(.fitted)), 
            colour = "black", size = 0.7)+
  geom_smooth(method = "lm", se = F, linetype = "dotted", size = 0.7, colour = "darkred")+
  geom_ribbon(aes(x = richness, 
                  ymin = exp(.fitted - 2*.se.fit), 
                  ymax = exp(.fitted + 2*.se.fit),
                  group = environment), fill = "grey", alpha = 0.2)+
  facet_wrap(~environment, scales = "free_y")+
  theme_bw()


```

##BEF metrics

We calculate the slope between richness and functioning for all combinations of environments. 

+ for all scales (1:5 environments)
+ for all possible unique combinations of environments 

We calculate the functioning of a given species mixture in that combination of environemnts at that scale as the average functioning of that species mixture in the single environments. 

For each scale and environment combination we then calculate the following metrics:

+ the **linear slope** of the richness ~ functioning relationship
+ the **slope of a power fit** to the richness ~ functioning relationship
+ **overyielding**: highest mixture value / mean monoculture value
+ **transgressive overyielding**: highest mixture value / maximum monoculture value


```{r, warning=FALSE}

plot_values_wide <- 
plot_values_df %>% 
  spread(environment, functioning)

#calculate average functioning for each env combination at each scale and store results in dataframe
env_values <- 
lapply(env_comb, function(x) { #for all scales (1:5)
  apply(x, 2, function(y) { #for all environmental combinations
   
     df <- data.frame( #average functioning for this environment combination
       env_comb = paste0(y, collapse = " "),
       envnum = length(y),
       richness = plot_values_wide$richness,
       functioning = rowMeans(plot_values_wide[,y])
                     )
  })
  })

env_values <- bind_rows(unlist(env_values, recursive = FALSE))

# calculate BEF metrics for each environment combination
env_metrics <- 
  env_values %>% 
  group_by(env_comb, envnum) %>%
  nest() %>% 
  mutate(linear_fit = map(data, ~lm(functioning ~ richness, data = .))) %>% 
  mutate(linear_fit = map_dbl(linear_fit, function(x) coef(x)[2])) %>%
  #mutate(power_fit = map(data, ~nls(functioning ~ a*richness^b, data = ., start = list(a = 1, b = 1)))) %> 
  #mutate(power_fit = map_dbl(power_fit, function(x) coef(x)[2])) %>% 
  mutate(overyield = map_dbl(data, function(x) {
    x[x$richness == specnum,]$functioning / 
      mean(x[x$richness == 1,]$functioning)
    })) %>% 
  mutate(transgressive = map_dbl(data, function(x) {
    x[x$richness == specnum,]$functioning / 
      max(x[x$richness == 1,]$functioning)})) 

```

### Fig 2a - power-fits 

```{r}
if(Scenario %in% c(1,3)){
Fig_2_a <- 
env_values %>%
  group_by(envnum) %>% 
  nest() %>% 
  mutate(power_fit = map(data, ~nls(functioning ~ a*richness^b, data = ., start = list(a = 1, b = 1)))) %>%
  mutate(power_fit = map(power_fit, augment)) %>% 
  unnest(cols = power_fit) %>% 
  ggplot(aes(x = richness, y = functioning, colour = as.factor(envnum)))+
  geom_point( size = 1, alpha = 1, position = position_dodge(width = 0.7))+
  geom_line(aes(y = .fitted, group = envnum), position = position_dodge(width = 0.7))+
  scale_color_manual(values = viridis(envnum+1)[1:envnum], name = "scale")+
  theme_classic()+
  labs(y = "production", x = "species richness")+
  guides(colour = guide_legend(ncol = 3))+
  theme(legend.position = c(0.85,0.15), 
        legend.background = element_rect(fill = "transparent"),
        axis.ticks.length=unit(-0.25, "cm"),
        axis.text.x = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")),
        axis.text.y = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")))
}

if(Scenario == 2){
Fig_2_a <- 
env_values %>%
  group_by(envnum) %>% 
  nest() %>% 
  mutate(fit = map(data, ~lm(functioning ~ richness, data = .))) %>%
  mutate(fit = map(fit, augment)) %>% 
  unnest(cols = fit) %>% 
  ggplot(aes(x = richness, y = functioning, colour = as.factor(envnum)))+
  geom_point( size = 1, alpha = 1, position = position_dodge(width = 0.7))+
  geom_line(aes(y = .fitted, group = envnum), position = position_dodge(width = 0.7))+
  scale_color_manual(values = viridis(envnum+1)[1:envnum], name = "scale")+
  theme_classic()+
  labs(y = "production", x = "species richness")+
  guides(colour = guide_legend(ncol = 3))+
  theme(legend.position = c(0.85,0.15), 
        legend.background = element_rect(fill = "transparent"),
        axis.ticks.length=unit(-0.25, "cm"),
        axis.text.x = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")),
        axis.text.y = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")))
}

if(Scenario == 3) {
  save("Fig_2_a", file = here("figures", "Fig_2_a.RData"))
  } else if(Scenario == 2) {
  save("Fig_2_a", file = here("figures", "Fig_S1_a.RData"))
    } else if(Scenario == 1) {
    save("Fig_2_a", file = here("figures", "Fig_S1_d.RData"))}

env_values %>%
  group_by(richness, env_comb, envnum) %>% 
  summarise(functioning = mean(functioning)) %>% 
  filter(richness %in% c(1,5)) %>% 
  ggplot(aes(x = richnes, y = functioning, group = env_comb))+
  geom_point( size = 0.8, alpha = 1)+
  geom_line( size = 0.5, alpha = 1)+
  facet_wrap(~envnum)+
  #geom_smooth(method = 'lm', aes(group = 1))+
  theme_bw()+
  theme(legend.position = "none")


env_values %>% 
  filter(envnum == 5) %>% 
  ggplot(aes(x = richness, y = functioning, colour = as.factor(envnum)))+
  geom_point()+
  geom_smooth(method = "lm", aes(group = 1))

```
### power-fit statistics
```{r}

env_values %>%
  group_by(envnum) %>% 
  nest() %>% 
  mutate(power_fit = map(data, ~nls(functioning ~ a*richness^b, data = ., start = list(a = 1, b = 1)))) %>% 
  mutate(power_fit = map(power_fit, tidy)) %>% 
  unnest(cols = power_fit) %>% 
  filter(term == "b") %>% 
  select(envnum, estimate, p.value) %>% 
  ungroup() %>% 
  mutate_if(is.numeric, round, digits = 3) %>% 
  group_by(envnum) %>% 
  summarise(mean(estimate))


```

### Fig 2b - overyielding
```{r}
Fig_2_b <- 
env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>%
  filter(metric == "overyield") %>% 
  ggplot(aes(x = envnum, y = value, colour = as.factor(envnum)))+
  geom_point( size = 4, alpha = 1, position = position_jitter(width = 0.1))+
  stat_smooth(method = "lm", se = F, size = 0.5, colour = "darkred")+
  scale_color_manual(values = viridis(envnum+1)[1:envnum], name = "scale")+
  theme_classic()+
  labs(y = "overyielding", x = "scale")+
  theme(legend.position = "none",
        axis.ticks.length=unit(-0.25, "cm"),
        axis.text.x = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")),
        axis.text.y = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")) )+
  NULL

if(Scenario == 3) {
  save("Fig_2_b", file = here("figures", "Fig_2_b.RData"))
  } else if(Scenario == 2) {
  save("Fig_2_b", file = here("figures", "Fig_S1_b.RData"))
    } else if(Scenario == 1) {
    save("Fig_2_b", file = here("figures", "Fig_S1_e.RData"))}


Fig_2_b


test <- list(1, 2, 3, 7)

combos <- sapply(1:length(test), function(x) {combn(test, x)})

lapply(combos, function(x) max(unlist(x)))

combos[[4]]

env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>%
  filter(metric == "overyield") %>% 
  group_by(envnum) %>% 
  summarise(mean = mean(value))
```

### overyielding statistics
```{r}

env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>%
  filter(metric == "overyield") %>% 
  lm(value ~ envnum, data = .) %>% 
  tidy %>% 
  mutate_if(is.numeric, round, 3)

```

### Fig 2c - transgressive overyielding
```{r}

Fig_2_c <- 
env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>% 
  filter(metric == "transgressive") %>% 
  ggplot(aes(x = envnum, y = value, colour = as.factor(envnum)))+
  geom_point( size = 4, alpha = 1, position = position_jitter(width = 0.1))+
  stat_smooth(method = "lm", se = F, size = 0.5, colour = "darkred")+
  scale_color_manual(values = viridis(envnum+1)[1:envnum], name = "scale")+
  theme_classic()+
  labs(y = "transgressive overyielding", x = "scale")+
  theme(legend.position = "none",
        axis.ticks.length=unit(-0.25, "cm"),
        axis.text.x = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")),
        axis.text.y = element_text(margin=unit(c(0.5,0.5,0.5,0.5), "cm")) )+
  #coord_fixed(ratio = 2/0.2)+
  NULL


if(Scenario == 3) {
  save("Fig_2_c", file = here("figures", "Fig_2_c.RData"))
  } else if(Scenario == 2) {
  save("Fig_2_c", file = here("figures", "Fig_S1_c.RData"))
    } else if(Scenario == 1) {
    save("Fig_2_c", file = here("figures", "Fig_S1_f.RData"))}

Fig_2_c
```


### transgressive overyielding - statistics
```{r}
env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>%
  filter(metric == "transgressive") %>% 
  lm(value ~ envnum, data = .) %>% 
  tidy %>% 
  mutate_if(is.numeric, round, 3)

```


# multiple draws from uniform

In the above example with took a single draw for the trait values from the uniform distribution. In the code below, we repeat this 500 times to get a distribution of BEF results from multiple draws

## fitness values
```{r}
Traits <- matrix(
  nrow = length(env),
  ncol = length(spec),
  dimnames = list(env, spec))


# take N random draws

N <- 1000

Trait_list <- 
lapply(1:N, function(x) {Traits[1:nrow(Traits), 1:ncol(Traits)] <-
  runif( n = prod( dim( Traits)), 0, 1)
return(Traits)})



```


##plot values
```{r}

# choose scenario

# 1 = Dominance
# 2 = Mean
# 3 = Weighted mean


Scenario <- 3

plot_values_df_list <- 
pblapply(Trait_list, function(TM) {

plot_values <- sapply(env, #for each environment
                      function(x) {
                        lapply(spec_comb, #for each richness level
                               function(y) {
                                 apply(y, 2, function(z){ #for each species combination
                                   if(Scenario == 1){
                                     max(TM[x,z])
                                     } else if(Scenario == 2){
                                     mean(TM[x,z])
                                       } else {
                                         mean(sum(TM[x,z]^2) / abs(sum(TM[x,z])))
                                       } 
                                   }
                                   )
                                 }
                               )
                        }
                      )


plot_values_df <- 
  tibble(
    richness = rep( rep(1:specnum, unlist(lapply(spec_comb, ncol))), envnum),
    spec_comb = rep(lapply(spec_comb, 
                           function(x) apply(x, 2, function(y) 
                             paste(y, collapse = " "))) %>% unlist(),
                    envnum),
    environment = rep(env, each = sum(choose(specnum,1:specnum))),
    functioning = unlist(plot_values)
    )

return(plot_values_df)
})
```


##BEF metrics
```{r}

env_metrics_list <- 
  pblapply(plot_values_df_list, function(PV) {
    
    plot_values_wide <-
      PV %>% 
      spread(environment, functioning)

#calculate average functioning for each env combination at each scale and store results in dataframe
env_values <- 
lapply(env_comb, function(x) { #for all scales (1:5)
  apply(x, 2, function(y) { #for all environmental combinations
   
     df <- data.frame( #average functioning for this environment combination
       env_comb = paste0(y, collapse = " "),
       envnum = length(y),
       richness = plot_values_wide$richness,
       functioning = rowMeans(plot_values_wide[,y]),
       stringsAsFactors = FALSE
                     )
  })
  })

env_values <- bind_rows(unlist(env_values, recursive = FALSE))

# calculate BEF metrics for each environment combination
env_metrics <- 
  env_values %>% 
  group_by(env_comb, envnum) %>%
  nest() %>% 
  mutate(overyield = map_dbl(data, function(x) {
    x[x$richness == specnum,]$functioning / 
      mean(x[x$richness == 1,]$functioning)
    })) %>% 
  mutate(transgressive = map_dbl(data, function(x) {
    x[x$richness == specnum,]$functioning / 
      max(x[x$richness == 1,]$functioning)})) 


overyield <- 
env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>%
  filter(metric == "overyield") %>% 
  lm(value ~ envnum, data = .) %>% 
  coef %>% 
  `[`(2)


transgressive <- 
env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>%
  filter(metric == "transgressive") %>% 
  lm(value ~ envnum, data = .) %>% 
   coef %>% 
  `[`(2)

beta_slopes <- 
env_values %>% 
  group_by(envnum, env_comb) %>%
  nest() %>% 
  mutate(power_fit = map(data, ~nls(functioning ~ a*richness^b, data = ., start = list(a = 1, b = 1)))) %>% 
  mutate(beta = map_dbl(power_fit, function(x) coef(x)[2])) %>% 
  lm(beta~envnum, data = .) %>% 
  coef %>% 
  `[`(2)
  
  

return(tibble(overyield = overyield, 
              transgressive = transgressive,
              beta_slopes = beta_slopes))
    
    
  })


```

```{r}
Results <- 
bind_rows(env_metrics_list)
```

```{r}
Results %>% 
  gather(metric, value) %>% 
  ggplot(aes(x = value, fill = metric))+
  geom_histogram(binwidth = 0.005)+
  facet_wrap(~metric)+
  geom_vline(xintercept = 0, linetype = "dashed")+
  theme_bw()+
  scale_fill_brewer(palette = "Set1")
```


# Simulations for full environment x scale gradient (not included)

 + make 'heat map' graph with heterogeneity vs scale filled with e.g. av transgressive overyielding
 + test which scenario fits model best, by correlating expected yield based on mono-culture data with three scenarios (average, weighted average, dominance)

 
```{r}

# vector of environemnts
ab <- as.character(unique(plot_values_df$environment))

#vector of all possible environment combinations *including with repeated environments*
ab_comb <- sapply(1:length(ab), function(x) gtools::combinations(length(ab), x, ab, repeats.allowed=TRUE))
  # apply(1, table) #%>% 
  # bind_rows() #%>% 
  # vegan::renyi(., scales = 1, hill = T)

env_values <- 
lapply(ab_comb, function(x) { #for all levels of environmental richness (1:5)
  apply(x, 1, function(y) { #for all combination of environments
   
     df <- tibble(
       env_comb = paste0(y, collapse = " "), # which combination of environemnts
       envnum = length(y), # what environmental richness
       envdiv = as.numeric(vegan::renyi(table(y), scales = 1, hill = T)),
       richness = plot_values_wide$richness, 
       gene = plot_values_wide$spec_comb,
       functioning = rowMeans(plot_values_wide[,y]) #mean of functioning across environments
                     )
  })
  })

# expand to dataframe with average function for each 
# species richness level, 
# each species combination,
# and each environmental combination


env_values <- bind_rows(unlist(env_values, recursive = FALSE))
```



```{r}
env_metrics <- 
  env_values %>% 
  group_by(env_comb, envnum, envdiv) %>%
  nest() %>% 
  mutate(linear_fit = map(data, ~lm(functioning ~ richness, data = .))) %>%
  mutate(linear_fit = map_dbl(linear_fit, function(x) coef(x)[2])) %>% 
  mutate(log_fit = map(data, ~lm(log(functioning) ~ log(richness), data = .))) %>% 
  mutate(log_fit = map(log_fit, tidy)) %>% 
  unnest(log_fit) %>% 
  select(-std.error, -statistic, -p.value) %>% 
  spread(term, estimate) %>% 
  mutate(power_fit = map(data, ~nls(functioning ~ a*richness^b, data = ., 
                                    start = list(a = exp(`(Intercept)`) , b = `log(richness)`)))) %>%  
  mutate(power_fit = map_dbl(power_fit, function(x) coef(x)[2])) %>% 
   mutate(overyield = map_dbl(data, function(x) {
     mean(x[x$richness == specnum,]$functioning, na.rm = T) / 
       mean(x[x$richness == 1,]$functioning, na.rm = T)})) %>% 
  mutate(transgressive = map_dbl(data, function(x) {
    x %>% 
      group_by(gene) %>% 
      filter(richness %in% c(1, specnum)) %>% 
      summarise(functioning = mean(functioning, na.rm = T), richness = unique(richness)) %>% 
      group_by(richness) %>% 
      summarise(functioning = max(functioning, na.rm = T)) %>% 
      {.[.$richness == specnum,]$functioning /
          .[.$richness == 1,]$functioning}
    })) %>%
  mutate(transgressive = (transgressive-1)*100) %>% 
  {.}

res <- 
env_metrics %>% 
  group_by(envnum, envdiv) %>%
  summarise(transgressive = mean(transgressive))

res_int <- akima::interp(res$envnum, res$envdiv, res$transgressive)
 
df <- 
expand_grid(envnum = res_int$x, envdiv = res_int$y) %>% 
  as_tibble() %>% 
  mutate(transgressive = c(t(res_int$z))) %>% 
  na.omit()

ggplot(df, aes(x = envdiv ,y = envnum , fill = transgressive))+
  geom_raster()+
  geom_point(data = res, shape = 22, colour = "red", size = 4)+
  scale_fill_viridis_c()+
  theme_bw()


```

