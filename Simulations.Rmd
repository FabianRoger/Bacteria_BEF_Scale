---
title: "Bacterial EF across Scale - Simulations"
output: html_notebook
---

```{r, message=FALSE}
library(dplyr)
#library(tibble)
library(tidyr)
library(purrr)
library(ggplot2)
library(broom)
#library(raster) (for now only needed for last visualization)
library(akima)
```

+ We want to simulate 5 strains of Bacteria, growing on 4 different antibiotics & the control. 
+ Each Strain differs in it's ability to grow on each antibiotic
+ We grow the bacteria in every possible combination (monocultures and all possibel 2 to 5 species mixtures)
+ We grow them on every possible combination of environments (1 antibiotics to 4 antibiotics + control)
+ We measure EF at different scales going from 1 to 1000 pixels  

  
Dimensions and replication: 44*28 / 63

define number of species and environments
```{r}

specnum <- 5
envnum <- 5
 
```

#strains
```{r}

spec <- paste("strain_", c(1:specnum), sep = "")
spec_comb <- sapply(c(1:specnum), function(x) combn(spec, x)) 
names(spec_comb) <- paste("richness", c(1:specnum))

#spec_comb

```

# Antibiotics
```{r}
env <- paste("Environment_", c(1:envnum), sep = "")

env_comb <- sapply(c(1:envnum), function(x) combn(env, x)) 
names(env_comb) <- paste("Heterogeneity", c(1:envnum))

#env_comb

```

number of combinations

```{r}
tibble(spec_combs = 
         sum(choose(specnum,1:specnum)),
       env_combs = 
         sum(choose(envnum,1:envnum)))
```

#strain performance

points to ponder:
+ does each environment has another 'best' species?
+ is the average performance of all species equal for all environments?

```{r}

Traits <- matrix(
  nrow = length(env),
  ncol = length(spec),
  dimnames = list(env, spec))

# Traits[,"strain_1"] <- c(1, 0.7, 0.5, 0.2)
# Traits[,"strain_2"] <- c(0.2, 1, 0.7, 0.5)
# Traits[,"strain_3"] <- c(0.5, 0.2, 1, 0.7)
# Traits[,"strain_4"] <- c(0.7, 0.5, 0.2, 1)

Traits[1:nrow(Traits), 1:ncol(Traits)] <-
  runif( n = prod( dim( Traits)), 0, 1)

Traits
```

# plot values

here we calculate the outcome (biomass / 'functioning') of every species combination in each environment. We calculate the mixture performance in three differen ways:

1) **Dominance**: The mixture value equals the perfomance of the best performing species 
2) **Mean**: The mixture value equals the mean of the performances of all species 
3) **Weighted mean**: The mixture value equals the mean performance of all species, weighted by their relative performance in the environemnt

**what the code does**

*for each environment `sapply(env, ...` it cycles through all richness levels `lapply(spec_comb, ...)` and for each richness level it cycles through all species combinations `apply(..., 2, )`.
Then it calculates the the mixture performance of that species combination of that richness level in that environment given the species performance stored in `Traits` and given the rules given by the chosen `Scenario`*


```{r}

# choose scenario

# 1 = Dominance
# 2 = Mean
# 3 = Weighted mean


Scenario <- 3

plot_values <- sapply(env, #for each environment
                      function(x) {
                        lapply(spec_comb, #for each richness level
                               function(y) {
                                 apply(y, 2, function(z){ #for each species combination
                                   if(Scenario == 1){
                                     max(Traits[x,z])
                                     } else if(Scenario == 2){
                                     mean(Traits[x,z])
                                       } else {
                                         mean(sum(Traits[x,z]^2) / abs(sum(Traits[x,z])))
                                       } 
                                   }
                                   )
                                 }
                               )
                        }
                      )


plot_values_df <- 
  tibble(
    richness = rep( rep(1:specnum, unlist(lapply(spec_comb, ncol))), envnum),
    spec_comb = rep(lapply(spec_comb, 
                           function(x) apply(x, 2, function(y) 
                             paste(y, collapse = " "))) %>% unlist(),
                    envnum),
    environment = rep(env, each = sum(choose(specnum,1:specnum))),
    functioning = unlist(plot_values)
    )

```

# plot for single environments
```{r}
ggplot(plot_values_df, aes(x = richness, y = functioning, colour = environment))+
   geom_point(position = position_dodge(width = 0.4))+
  geom_smooth(method = "lm", se = F, position = position_dodge(width = 0.4))+
    scale_colour_brewer(palette = "Set1")+
    theme_bw()

plot_values_df %>% 
  na.omit() %>% 
  group_by(environment) %>%
  nest() %>% 
  mutate(power_fit = map(data, ~lm(log(functioning) ~ log(richness), data = .))) %>% 
  mutate(power_fit = map(power_fit, augment)) %>% 
  unnest(cols = c(data, power_fit)) %>% 
  ggplot(aes(x = richness, y = functioning))+
  geom_point(position = position_jitter(width = 0.1, height = 0), 
             alpha = 1, size = 1, colour = "#377EB8")+
  geom_line(aes(x = richness, y = exp(.fitted)), 
            colour = "black", size = 1)+
  geom_ribbon(aes(x = richness, 
                  ymin = exp(.fitted - 2*.se.fit), 
                  ymax = exp(.fitted + 2*.se.fit),
                  group = environment), fill = "grey", alpha = 0.2)+
  facet_wrap(~environment, scales = "free_y")+
  theme_bw()


```

#extract slopes for all scales 

here we calculate the slope between richness and functioning for all combinations of environments

```{r, warning=FALSE}

plot_values_wide <- 
plot_values_df %>% 
  spread(environment, functioning)

env_values <- 
lapply(env_comb, function(x) {
  apply(x, 2, function(y) {
   
     df <- data.frame(
       env_comb = paste0(y, collapse = " "),
       envnum = length(y),
       richness = plot_values_wide$richness,
       functioning = rowMeans(plot_values_wide[,y])
                     )
  })
  })

env_values <- bind_rows(unlist(env_values, recursive = FALSE))

env_metrics <- 
  env_values %>% 
  group_by(env_comb, envnum) %>%
  nest() %>% 
  mutate(linear_fit = map(data, ~lm(functioning ~ richness, data = .))) %>%
  mutate(linear_fit = map_dbl(linear_fit, function(x) coef(x)[2])) %>% 
  mutate(power_fit = map(data, ~nls(functioning ~ a*richness^b, data = ., start = list(a = 1, b = 1)))) %>% 
  mutate(power_fit = map_dbl(power_fit, function(x) coef(x)[2])) %>% 
  mutate(overyield = map_dbl(data, function(x) {
    x[x$richness == specnum,]$functioning / 
      mean(x[x$richness == 1,]$functioning)})) %>% 
  mutate(overyield = (overyield-1)*100) %>% 
  mutate(transgressive = map_dbl(data, function(x) {
    x[x$richness == specnum,]$functioning / 
      max(x[x$richness == 1,]$functioning)})) %>%  #change to update in real data
  mutate(transgressive = (transgressive-1)*100)

```

```{r}
env_values %>% 
  group_by(envnum) %>% 
  mutate(group = as.numeric(as.factor(env_comb))) %>% 
  ggplot(aes(x = as.factor(richness), y = functioning, 
             colour = as.factor(group)))+
  geom_point(aes(group = group), 
             position = position_jitterdodge(dodge.width = 0.4, jitter.width = 0.1), 
             size = 1)+
  geom_smooth(method = "lm", aes(group = env_comb),
              se = F, position = position_dodge(width = 0.7),
              size= 0.5, alpha = 0.7, linetype = "dashed")+
  geom_smooth(method = "lm", aes(group = as.factor(envnum)), 
              se = F, position = position_dodge(width = 0.7), 
              colour = brewer.pal(11,"RdYlGn")[1],
              size = 0.7)+
  facet_wrap(~envnum)+
  #scale_colour_manual(values = c(brewer.pal(9,"Blues")[9:3]))+
  theme_bw()+
  theme(legend.position = "none")
  

```


```{r}

ggplot(env_values, aes(x = as.factor(richness), y = functioning, colour = as.factor(envnum)))+
  geom_point(position = position_dodge(width = 0.7), size = 0.7, alpha = 0.5)+
  scale_color_brewer(palette = "Set1")+
  geom_smooth(method = "lm", aes(group = envnum), se = F, position = position_dodge(width = 0.7), size= 0.5)+
  theme_bw()

```

```{r}


Col <- c(brewer.pal(9, "Greens")[c(5,7,9)], brewer.pal(9, "Blues")[c(5,7,9)])[c(1,4,2,5,3,6)]

env_values %>%
  group_by(envnum) %>% 
  nest() %>% 
  mutate(power_fit = map(data, ~nls(functioning ~ a*richness^b, data = ., start = list(a = 1, b = 1)))) %>%  
  mutate(power_fit = map(power_fit, augment)) %>% 
  unnest(cols = power_fit) %>% 
  ggplot(aes(x = richness, y = functioning, colour = as.factor(envnum)))+
  geom_point( size = 1, alpha = 1, position = position_dodge(width = 0.7))+
  geom_line(aes(y = .fitted, group = envnum), position = position_dodge(width = 0.7))+
  scale_color_manual(values = Col, name = "number of \nenvironments")+
  theme_bw()+
 # scale_y_log10()+
# scale_x_log10()
 # ylim(c(0, 6e8))+ #omit two outliers for clarity?
  labs(y = "average functioning", x = "species richness")+
  guides(colour = guide_legend(ncol = 3))+
  theme(legend.position = c(0.85,0.15), 
        legend.background = element_rect(fill = "transparent"))
  
```


```{r}

d <- tibble(linear_fit = c(-0.2,0.2),
            overyield = c(-20, 20),
            power_fit = c(-0.2,0.2),
            transgressive = c(-50, 50)) %>% 
  gather(metric, value)

env_metrics %>% 
  select(-data) %>% 
  gather(metric, value, -envnum, -env_comb) %>% 
  ggplot(aes(x = envnum, y = value))+
  geom_point(position = position_jitter(width = 0.1), fill = "dodgerblue3", size = 2, shape = 21, alpha = 0.7)+
  facet_wrap(~metric, scales = "free_y")+
  stat_smooth(method = "lm", se = F, size = 0.5, colour = "darkred")+
  theme_bw()+
  labs(x = "number of environments")+
  geom_blank(data = d)
  
  
```





# To-do

 + make 'heat map' graph with heterogeneity vs scale filled with e.g. av transgressive overyielding
 + test which scenario fits model best, by correlating expected yield based on mono-culture data with three scenarios (average, weighted average, dominance)
 + 
 
```{r}

# vector of environemnts
ab <- as.character(unique(plot_values_df$environment))

#vector of all possible environment combinations *including with repeated environments*
ab_comb <- sapply(1:length(ab), function(x) gtools::combinations(length(ab), x, ab, repeats.allowed=TRUE))
  # apply(1, table) #%>% 
  # bind_rows() #%>% 
  # vegan::renyi(., scales = 1, hill = T)

env_values <- 
lapply(ab_comb, function(x) { #for all levels of environmental richness (1:5)
  apply(x, 1, function(y) { #for all combination of environments
   
     df <- tibble(
       env_comb = paste0(y, collapse = " "), # which combination of environemnts
       envnum = length(y), # what environmental richness
       envdiv = as.numeric(vegan::renyi(table(y), scales = 1, hill = T)),
       richness = plot_values_wide$richness, 
       gene = plot_values_wide$spec_comb,
       functioning = rowMeans(plot_values_wide[,y]) #mean of functioning across environments
                     )
  })
  })

# expand to dataframe with average function for each 
# species richness level, 
# each species combination,
# and each environmental combination


env_values <- bind_rows(unlist(env_values, recursive = FALSE))
```



```{r}
env_metrics <- 
  env_values %>% 
  group_by(env_comb, envnum, envdiv) %>%
  nest() %>% 
  mutate(linear_fit = map(data, ~lm(functioning ~ richness, data = .))) %>%
  mutate(linear_fit = map_dbl(linear_fit, function(x) coef(x)[2])) %>% 
  mutate(log_fit = map(data, ~lm(log(functioning) ~ log(richness), data = .))) %>% 
  mutate(log_fit = map(log_fit, tidy)) %>% 
  unnest(log_fit) %>% 
  select(-std.error, -statistic, -p.value) %>% 
  spread(term, estimate) %>% 
  mutate(power_fit = map(data, ~nls(functioning ~ a*richness^b, data = ., 
                                    start = list(a = exp(`(Intercept)`) , b = `log(richness)`)))) %>%  
  mutate(power_fit = map_dbl(power_fit, function(x) coef(x)[2])) %>% 
   mutate(overyield = map_dbl(data, function(x) {
     mean(x[x$richness == specnum,]$functioning, na.rm = T) / 
       mean(x[x$richness == 1,]$functioning, na.rm = T)})) %>% 
  mutate(transgressive = map_dbl(data, function(x) {
    x %>% 
      group_by(gene) %>% 
      filter(richness %in% c(1, specnum)) %>% 
      summarise(functioning = mean(functioning, na.rm = T), richness = unique(richness)) %>% 
      group_by(richness) %>% 
      summarise(functioning = max(functioning, na.rm = T)) %>% 
      {.[.$richness == specnum,]$functioning /
          .[.$richness == 1,]$functioning}
    })) %>%
  mutate(transgressive = (transgressive-1)*100) %>% 
  {.}

res <- 
env_metrics %>% 
  group_by(envnum, envdiv) %>%
  summarise(transgressive = mean(transgressive))

res_int <- akima::interp(res$envnum, res$envdiv, res$transgressive)
 
df <- 
expand_grid(envnum = res_int$x, envdiv = res_int$y) %>% 
  as_tibble() %>% 
  mutate(transgressive = c(t(res_int$z))) %>% 
  na.omit()

ggplot(df, aes(x = envdiv ,y = envnum , fill = transgressive))+
  geom_raster()+
  geom_point(data = res, shape = 22, colour = "red", size = 4)+
  scale_fill_viridis_c()+
  theme_bw()


```

